<!DOCTYPE html>
<html>
<head>
  <title>Test StreamSaver.js</title>
</head>
<body>
<!-- <script src="https://cdn.jsdelivr.net/npm/web-streams-polyfill@2.0.2/dist/ponyfill.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.3/StreamSaver.min.js"></script>
<script>
  import streamSaver from 'streamsaver'
  const streamSaver = require('streamsaver')
  const streamSaver = window.streamSaver
</script> -->
<!-- <script>
  let content = "this is a test\n";
  for (let i = 0; i < 25; i++) {
    content += content;
  }
  console.log('create content', content.length);
  const uInt8 = new TextEncoder().encode(content)
  console.log('created byte array', uInt8.length);
  let manual = true;
  // streamSaver.createWriteStream() returns a writable byte stream
  // The WritableStream only accepts Uint8Array chunks
  // (no other typed arrays, arrayBuffers or strings are allowed)
  const fileStream = streamSaver.createWriteStream('filename.txt', {
    size: uInt8.byteLength, // (optional filesize) Will show progress
    writableStrategy: undefined, // (optional)
    readableStrategy: undefined  // (optional)
  })

  if (manual) {
    console.log('start manual writer');
    const writer = fileStream.getWriter()
    writer.write(uInt8)
    writer.close()
    console.log('end manual writer');
  } else {
    // using Response can be a great tool to convert
    // mostly anything (blob, string, buffers) into a byte stream
    // that can be piped to StreamSaver
    //
    // You could also use a transform stream that would sit
    // between and convert everything to Uint8Arrays
    console.log('start pipe');
    new Response('StreamSaver is awesome').body
      .pipeTo(fileStream)
      .then(success, error)

    console.log('end pipe');
  }
</script> -->
<!-- <script>
let rawLine = "this is a test\n";
const encodedLine = new TextEncoder().encode(rawLine);
const numLines = 1000000;
const length = encodedLine.byteLength * numLines;

const fileStream = streamSaver.createWriteStream('filename.txt', {
    size: length, // (optional filesize) Will show progress
    writableStrategy: undefined, // (optional)
    readableStrategy: undefined  // (optional)
  })

const writer = fileStream.getWriter();
console.log('start writer');
for (let line = 0; line < numLines; line++) {
  writer.write(encodedLine)
}

writer.close();
console.log('end writer');
</script> -->
<div>
Select file <input type="file" id="fileInput">
</div>
<div>
<button id="zipBtn" onclick="createZip()">Create Zip</button>
</div>
<div>
<button id="btn">Save File</button>
</div>

<!-- <script>
  let rawLine = "this is a test\n";
  const encodedLine = new TextEncoder().encode(rawLine);
  const numLines = 1000000;
  const length = encodedLine.byteLength * numLines;

  const button = document.querySelector('#btn');
  button.addEventListener('click', SaveFile);

  async function SaveFile() {

    if( !("showSaveFilePicker" in self) ) {
      throw new Error( "unsupported browser" );
    }
    
    const handle = await showSaveFilePicker({
      suggestedName: 'random_client_gen_file.bin'
    });
    console.log('handle', handle);
    
    const targetSize = 100 * 1024 * 1024;
    const bufferSize = 16 * 1024 * 1024;
    const numRounds = targetSize / bufferSize;

    const writer = await handle.createWritable();
    console.log('start writer', writer);

    const buffer = new ArrayBuffer(bufferSize);
    const uint8 = new Uint8Array(buffer);

    const start = Date.now();
    for (let rounds = 0; rounds < numRounds; rounds++) {
      for (let n = 0; n < buffer.byteLength; n++) {
        const byte = Math.floor(Math.random() * 256);
        uint8[n] = byte;
      }

      await writer.write(uint8);
    }
    const end = Date.now();
    console.log('took', end - start, 'ms');
    await writer.close();
    console.log('end writer');
  }
</script> -->
<script>
  const downloadUrl = "https://quickbytetestcentralfr.blob.core.windows.net/data/f4c87ad3910dab13929473eb2b9ea08e/a51f2fb578184fc10cf12ee6a8e702c9?sv=2022-11-02&se=2023-07-31T05%3A17%3A29Z&sr=b&sp=r&sig=70q%2FUMKATC%2F5SxO8FnCF0p0cfhRn6xj09q0V4CblwVY%3D&rscd=attachment%3B%20filename%3D%22random_file_1500.bin%22";
  const btn = document.querySelector("#btn");
  btn.addEventListener("click", downloadFile)

  async function downloadFile() {
    const bufferSize = 16 * 1024 * 1024;
    const handle = await showSaveFilePicker({
      suggestedName: 'downloadFile'
    });
    console.log('handle', handle);

    const writer = await handle.createWritable();
    console.log('start writer', writer);

    const start = Date.now();
    const response = await fetch(downloadUrl, {
      mode: 'cors'
    });

    const reader = response.body.getReader();
    console.log('reader', reader);
    console.log('res', response);

    let arrayBuffer = new ArrayBuffer(bufferSize);
    const buffer = new Uint8Array(arrayBuffer);

    let done = false;
    let bufferPos = 0;
    while (!done) {
      const result = await reader.read();
      let done = result.done;
      const chunk = result.value;
      if (!chunk) continue;
      for (let i = 0; i < chunk.length && bufferPos < bufferSize; i++) {
        buffer[bufferPos] = chunk[i];
        bufferPos++
      }

      if (bufferPos === buffer.length) {
        console.log('writing buffer', bufferPos);
        await writer.write(buffer.slice(0, bufferPos));
        bufferPos = 0;
      }
    }

    console.log('leftover buffer pos', bufferPos);
    if (bufferPos > 0) {
      await writer.write(buffer.slice(0, bufferPos));
    }
    
    let end = Date.now();
    console.log('completed write in', end - start, 'ms');
    await writer.close();
    console.log('completed file close in', Date.now() - start, 'ms');

  }
</script>
<script>
const crc32_table = function() {
    const tbl = [];
    var c;
    for(var n = 0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }

        tbl[n] = c;
    }

    return tbl;
}();

function crc32(arr) {
    var crc = -1;
    for(var i=0; i<arr.length; i++) {
        crc = (crc >>> 8) ^ crc32_table[(crc ^ arr[i]) & 0xFF];
    }
    return (crc ^ (-1)) >>> 0;
}
</script>
<script>

async function createZip() {
  // @type HTMLInputElement
  const fileInput = document.querySelector("#fileInput");
  const files = Array.from(fileInput.files);
  const file = files[0];
  const handle = await showSaveFilePicker({
    suggestedName: 'downloadFile'
  });

  const writer = await handle.createWritable();

  const fileBuffer = await readFileAsBlob(file);
  console.log('fileBlob', fileBuffer);
  const fileData = new Uint8Array(fileBuffer);
  console.log('file read', fileData);
  const fileSize = file.size;

  const textEncoder = new TextEncoder();
  const filename = file.name;
  const encodedName = textEncoder.encode(filename);
  const headerData = new Uint8Array(30 + encodedName.length);
  const dataView = new DataView(headerData.buffer);
  
  // off: 0, 4 bytes: Local file header signature = 0x04034b50 (PK♥♦ or "PK\3\4")
  // headerData[0] = 0x50;
  // headerData[1] = 0x4b;
  // headerData[2] = 0x03;
  // headerData[3] = 0x04;
  dataView.setUint32(0, 0x04034b50, true);
  // skip offset 4 to 13 (version, general purpose bit flag, compression method, last mod time, last mod date)
  
  // CRC-32 of uncompressed data
  const chksum = crc32(fileData);
  dataView.setUint32(14, chksum, true);
  // Compressed size
  dataView.setUint32(18, fileSize, true);
  // Uncompressied size
  dataView.setUint32(22, fileSize, true);
  // File name length
  dataView.setUint16(26, encodedName.length, true);
  // Extra field length
  dataView.setUint16(28, 0, true);
  // File name
  headerData.set(encodedName, 30);

  // write header
  await writer.write(headerData);
  // file data
  await writer.write(fileData);

  // CENTRAL DIRECTORY FILE HEADER
  const cdfHeader = new Uint8Array(46 + encodedName.length);
  const cdfDataView = new DataView(cdfHeader.buffer);
  // 0, 4, Central directory file header signature = 0x02014b50
  cdfDataView.setUint32(0, 0x02014b50, true);
  // skip offset to 15 (version made by, min version, general purpose bit flag, compression method, last mod time, last mode date)
  // CRC-32 of uncompressed data
  cdfDataView.setUint32(16, chksum, true);
  cdfDataView.setUint32(20, fileSize, true);
  cdfDataView.setUint32(24, fileSize, true);
  cdfDataView.setUint16(28, encodedName.length, true);
  cdfDataView.setUint32(34, 0, true);
  // 42, relative offset of local file header
  cdfDataView.setUint32(42, 0);
  // file name
  cdfHeader.set(encodedName, 46);
  await writer.write(cdfHeader);

  // END of central directory record
  const eocd = new Uint8Array(22);
  const eocdDataView = new DataView(eocd.buffer);
  // End of central directory signature = 0x06054b50
  eocdDataView.setUint32(0, 0x06054b50, true);
  // Number of central directory records on this disk (or 0xffff for ZIP64)
  eocdDataView.setUint16(8, 1, true);
  // Total number of central directory records (or 0xffff for ZIP64)
  eocdDataView.setUint16(10, 1, true);
  // Size of central directory (bytes) (or 0xffffffff for ZIP64)
  eocdDataView.setUint32(12, cdfHeader.length, true);
  // Offset of start of central directory, relative to start of archive (or 0xffffffff for ZIP64)
  eocdDataView.setUint32(16, headerData.length + fileSize, true);

  await writer.write(eocd);

  await writer.close();
}

function readFileAsBlob(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (evt) => {
      resolve(evt.target.result);
    };

    reader.readAsArrayBuffer(file);
  });
}
</script>
</body>
</html>